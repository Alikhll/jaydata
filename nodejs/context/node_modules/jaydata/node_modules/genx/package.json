{
  "name": "genx",
  "version": "0.9.0",
  "description": "Evented XML generation using the Genx C library",
  "keywords": [
    "xml",
    "generation",
    "generator",
    "builder"
  ],
  "homepage": "http://node-genx.wezm.net/",
  "author": {
    "name": "Wesley Moore",
    "email": "wes@wezm.net",
    "url": "http://www.wezm.net/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/wezm/node-genx.git"
  },
  "main": "./lib/genx",
  "engines": {
    "node": ">=0.6.0"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "https://github.com/wezm/node-genx/blob/master/LICENSE"
    }
  ],
  "scripts": {
    "preinstall": "node-waf configure build",
    "test": "mocha"
  },
  "readme": "node-genx\n=========\n\n[node.js][node] bindings to the [Genx][genx] XML generation library.\n\n[node]: http://nodejs.org/\n[genx]: http://www.tbray.org/ongoing/When/200x/2004/02/20/GenxStatus\n[npm]: http://npmjs.org/\n\nInstalling\n----------\n\n    npm install genx\n\nBuilding From Source\n--------------------\n\n    node-waf configure build\n\nExample\n-------\n\nThe following complete example uses Genx to reproduce the [brief, single-entry\nAtom Feed Document][specdoc] in the Atom spec. The result is written to stdout.\nNote that Genx does not do any formatting of the XML for you so unless you\ninsert the text nodes manually the result will all come out on one line. This\nis easy to fix by passing the result through <code>[xmllint]</code> (part of\n[libxml2]).\n\n[specdoc]: http://www.atomenabled.org/developers/syndication/atom-format-spec.php#rfc.section.1.1\n[xmllint]: http://xmlsoft.org/xmllint.html\n[libxml2]: http://xmlsoft.org/\n\n    var genx = require('genx');\n\n    var w = new genx.Writer();\n\n    w.on('data', function(data) {\n      process.stdout.write(data);\n    })\n\n    // Declare the elements and attributes up-front\n    var ns      = w.declareNamespace('http://www.w3.org/2005/Atom', '');\n    var feed    = w.declareElement(ns, 'feed');\n    var title   = w.declareElement(ns, 'title');\n    var link    = w.declareElement(ns, 'link');\n    var updated = w.declareElement(ns, 'updated');\n    var author  = w.declareElement(ns, 'author');\n    var name    = w.declareElement(ns, 'name');\n    var id      = w.declareElement(ns, 'id');\n    var entry   = w.declareElement(ns, 'entry');\n    var summary = w.declareElement(ns, 'summary');\n\n    var href    = w.declareAttribute('href');\n\n    // This is not a processing instruction and as such can't be generated by Genx\n    process.stdout.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n    w.startDocument()\n      .startElement(feed)\n        .startElement(title).addText(\"Example Feed\").endElement()\n        .startElement(link).addAttribute(href, \"http://example.org/\").endElement()\n        .startElement(updated).addText(\"2003-12-13T18:30:02Z\").endElement()\n        .startElement(author)\n          .startElement(name).addText(\"John Doe\").endElement()\n        .endElement()\n        .startElement(id).addText(\"urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6\").endElement()\n        .startElement(entry)\n          .startElement(title).addText(\"Atom-Powered Robots Run Amok\").endElement()\n          .startElement(link).addAttribute(href, \"http://example.org/2003/12/13/atom03\").endElement()\n          .startElement(id).addText(\"urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a\").endElement()\n          .startElement(updated).addText(\"2003-12-13T18:30:02Z\").endElement()\n          .startElement(summary).addText(\"Some text.\").endElement()\n        .endElement()\n      .endElement()\n    .endDocument();\n\nTo run the example and format it with `xmllint`:\n\n    node genx-atom.js | xmllint --format -\n\nFor more examples see, [Generating XML With node.js](http://www.wezm.net/technical/2011/01/generating-xml-with-node-js/).\n\nAPI\n---\n\nThe API pretty closely follows the underlying [Genx library's API][libapi].\nThis module exports one object, `Writer`, which you use to generate XML. Any\nerrors encountered are raised as exceptions.\n\n[libapi]: http://www.tbray.org/ongoing/genx/docs/Guide.html\n\n**Note:** Each of the following examples assumes the module has been imported\nand a `Writer` created as follows:\n\n    var genx = require('genx);\n    var writer = new genx.Writer();\n\n### Events\n\nThe `Writer` emits data events with a single string argument containing an XML\nfragment. You listen for data events in order to make use of the generated XML.\n\n    writer.on('data', function(data) {\n      // Do something with the data such as write it to a file\n    });\n\n### Writer\n\nThe Writer class provides the primary interface to Genx. Call writer methods to\ngenerate XML. XML can be generated via literal nodes (elements, attributes) or\nby reusing pre-declared nodes. The Genx documentation claims that using\npredeclared nodes are more efficient. Where it makes sense the methods return\n`this` allowing calls to be chained. For example:\n\n    writer.startDocument().startElement(elem)\n\n---\n\n#### startDocument()\n\nStarts an XML document. Must be called before any elements can be added. This\nmethod may be called on a `Writer` multiple times after completing each\ndocument with `endDocument` in order to re-use a `Writer` and generate multiple\ndocuments.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    writer.startDocument();\n\n---\n\n#### endDocument()\n\nEnds a document previously started with `startDocument`.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    writer.endDocument();\n\n---\n\n#### declareNamespace(uri, [prefix])\n\nDeclares a namespace for later use in `declareElement`.\n\n**Arguments**\n\n* uri (mandatory, String) -- the uri of the namespace\n* prefix (optional, String) -- the prefix that will be used for elements in\n  this namespace.  If the prefix is omitted Genx will generate one for you.\n  Generated prefixes are of the form \"gN\", where N starts at 1. If prefix is\n  the empty string, `\"\"`, then this namespace will be set as the default\n  namespace.\n\n**Return Value**\n\nReturns a `Namespace` object for later use with `declareElement`.\n\n**Examples**\n\n    // Namespace with prefix\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"atom\");\n\n    // Default namespace\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"\");\n\n    // Generated prefix\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom');\n\n### declareElement([namespace], name)\n\nDeclares an element with name `name` in namespace `namespace`. If\nno namespace is supplied then the element is in no namespace.\n\n**Arguments**\n\n* namespace (optional, Namespace) -- The namespace the element belongs to. Must\n  be a `Namespace` object returned by `declareNamespace`.\n* name (mandatory, String) -- The name of the element a.k.a. tag.\n\n**Return Value**\n\nReturns an `Element` object for later use with `startElement`.\n\n**Examples**\n\n    // Element without a namespace\n    var elem = writer.declareElement('test');\n\n    // Namespaced element\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom', \"\");\n    var elem = writer.declareElement(ns, 'feed');\n\n---\n\n#### declareAttribute([namespace], name)\n\nDeclares an attribute with name `name` in namespace `namespace`. If no\nnamespace is supplied then the attribute is in no namespace.\n\n**Arguments**\n\n* namespace (optional, String) -- The namespace the attribute belongs to. Must\n  be a `Namespace` object returned by `declareNamespace`.\n* name (mandatory, String) -- The name of the attribute. The value is supplied\n  later via `addAttribute`.\n\n**Return Value**\n\nReturns an `Attribute` object for later use with `addAttribute`.\n\n**Examples**\n\n    // Attribute without a namespace\n    var elem = writer.declareElement('type');\n\n    // Namespaced attribute\n    var ns = writer.declareAttribute('http://www.w3.org/2005/Atom', \"\");\n    var elem = writer.declareAttribute(ns, 'type');\n\n---\n\n#### startElement(element)\n\nOpens the element `element`.\n\n**Arguments**\n\n* element (mandatory, Element) -- The element to open. Must be an `Element`\n  object previously declared via `declareElement`.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    var elem = writer.declareElement('feed');\n\n    writer.startDocument()\n      .startElement(elem)\n      .endElement()\n    .endDocument()\n\n---\n\n#### startElementLiteral([namespace], name)\n\nOpens an element with name, `name` in namespace `namespace` (a URI) without\npre-declaring it.  The Genx documentation claims that pre-declaring is more\nefficient. Especially if the element is emitted multiple times.\n\n**Arguments**\n\n* namespace (optional, String) -- A namespace URI that the element belongs to.\n  If a prefix for this namespace has previously been declared via\n  `declareNamespace` then that prefix will be used, otherwise Genx will\n  generate one of the form described in `declareNamespace`.\n* name (mandatory, String) -- The name of the element to start.\n\n**Return Value**\n\nReturns the receiver.\n\n**Examples**\n\n    // Without a namespace\n    writer.startDocument()\n      .startElementLiteral('feed')\n      .endElement()\n    .endDocument()\n\n    // With a namespace\n    writer.startDocument()\n      .startElementLiteral('http://www.w3.org/2005/Atom', 'feed')\n      .endElement()\n    .endDocument()\n\n---\n\n#### addText(text)\n\nAdds a text node to the document.\n\n**Arguments**\n\n* text (mandatory, String) -- The text to add to the document.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    writer.startDocument()\n      .startElementLiteral('feed')\n        .addText(\"Some text\")\n      .endElement()\n    .endDocument()\n\n---\n\n#### addComment(comment)\n\n**Arguments**\n\n* comment (mandatory, String) -- The comment text to add to the document.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    writer.startDocument()\n      .addComment(\"Generated \" + (new Date()).toString())\n      .startElementLiteral('feed')\n      .endElement()\n    .endDocument();\n\n---\n\n#### addAttribute(attribute, value)\n\n**Arguments**\n\n* attribute (mandatory, Attribute) -- The attribute to add to the document.\n  Must be an `Attribute` object previously declared via `declareAttribute`.\n* value (mandatory, String) -- The attribute's value.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom', '');\n    var feed = writer.declareElement(ns, 'feed');\n    var title = writer.declareElement(ns, 'title');\n    var type = writer.declareAttribute('type');\n\n    writer.startDocument()\n      .startElement(feed)\n        .startElement(title)\n          .addAttribute(type, 'text')\n          .addText(\"Test Title\")\n        .endElement()\n      .endElement()\n    .endDocument();\n\n---\n\n#### addAttributeLiteral([namespace], name, value)\n\n**Arguments**\n\n* namespace (optional, String) -- A namespace URI that the attribute belongs\n  to.  If a prefix for this namespace has previously been declared via\n  `declareNamespace` then that prefix will be used, otherwise Genx will\n  generate one of the form described in `declareNamespace`.\n* name (mandatory, String) -- The attribute's name.\n* value (mandatory, String) -- The attribute's value.\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    var ns = writer.declareNamespace('http://www.w3.org/2005/Atom', '');\n    var feed = writer.declareElement(ns, 'feed');\n    var title = writer.declareElement(ns, 'title');\n\n    writer.startDocument()\n      .startElement(feed)\n        .startElement(title)\n          .addAttributeLiteral('type', 'text')\n          .addText(\"Test Title\")\n        .endElement()\n      .endElement()\n    .endDocument();\n\n---\n\n#### endElement()\n\n**Return Value**\n\nReturns the receiver.\n\n**Example**\n\n    writer.startDocument()\n      .startElementLiteral('feed')\n      .endElement()\n    .endDocument()\n\nRunning the Tests\n-----------------\n\nThis project has a test suite in the `test` directory. It utilises the\n[Mocha][mocha] test framework. To run the suite you need to have the\n`mocha` and `should` modules installed:\n\n    npm install -g mocha\n    npm install should\n\n[mocha]: http://visionmedia.github.com/mocha/\n\nThe suite is run by running `mocha` in the project root:\n\n    % mocha\n\n      ...................................\n\n      ✔ 35 tests complete (24ms)\n\nThis version of `node-genx` has only been tested on node 0.6.x.\n\nThere is also a Guardfile present that enables automatically rebuilding\nthe module and running the tests when one of the source files\nchange. To use this you need the `guard` and `guard-shell` Ruby gems\ninstalled. This can be done as follows:\n\n    gem install guard guard-shell\n\nThen run `guard` in the project root.\n\nContributors\n------------\n\n* Morten Siebuhr -- https://github.com/msiebuhr\n  * Applied fix for node-waf configuration errors on Linux\n\nChangelog\n---------\n\n* 0.9.0 -- 31 Jan 2012\n  * Update to support node 0.6.x\n* 0.8.3 -- 22 Jun 2011\n  * Fix build issues on Linux\n* 0.8.2 -- 25 Feb 2011\n  * Fix trailing comma in package.json\n",
  "_id": "genx@0.9.0",
  "_from": "genx@0.9.0"
}
